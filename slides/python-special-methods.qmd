---
title: "Object-oriented Programming"
subtitle: "Special Methods in Python's OOP"
author: |
    Khiem Nguyen 
    <br>Lecturer in Multiscale Materials
    <br><khiem.nguyen@glasgow.ac.uk>
author-meta: "Lecturer in Multiscale Materials"
format: 
    revealjs:
        theme: serif   # other themes: beige, blood, dark, dracula, league, moon, night, serif, simple, sky, solarized
        slide-number: true
        title-slide-style: pandoc
        echo: true
        code-overflow: wrap
        code-line-numbers: true
        code-block-bg: false          # <-- remove white background in code blocks
        # code-block-border-left: false # optional: remove left border
        # highlight-style: monokai      # good for dark images
        toc: true
        toc-depth: 1
        toc-title: Presentation Outline
        css: simple.css
execute:
    echo: false
---


# Special methods/Dunder methods
- Learn what Python's **special methods** (**dunder methods** or **magic methods**) are.
- Understand the magic behind magic methods in Python
- Customize different behaviors of your custom classes with **special methods**

## Special methods: Introduction
- A special method is a method whose name starts and ends with a double underscore.
- You already learned one of them: `__init__(self, ...)` is a constructor.
- These sepcial methods are known as **magic methods** or **dunder methods**
- The *double underscores** flag these methods as core to some Python features.

Some popular and well-known special methods:

| Magic Method | Description |
|---|---|
|`__init__()` | Provides an initializer in Python classes |
|`__str__()` | Provide human-read representation for objects |
|`__repr__()` | Provide developer point-of-view representation |
|`__call__()` | Makes instances of a class callable |
|`__len__()` | Supports the `len()` function |

## Special methods: Introduction
Here's how the Python official documentation defines the term **special methods**

> A method that is called implicitly by Python to execute a certain operation on a type, such as addition. Such methods have names starting and ending with double underscores. [Source](https://docs.python.org/3/glossary.html#term-special-method)

## Initializing Objects with `__init__()`

- You have learned it all the way. This method works as an **initializer**/**constructor** because it allows us to provide initial values to any *instance attributes* that we define in our classes.

```{python}
class Complex:
    def __init__(self, real=0, imag=0):
        self.real = real
        self.imag = imag

    def display(self):
        print(f"{self.real} + i*{self.imag}")
```

```{python}
a = Complex()
b = Complex(1, 2)
a.display()     # we wish to write print(a) instead
b.display()     #    wish to write print(b) instead
print(a)
print(b)
```

<!-- ::: {.fragment}
```{python}
# We wish that we can plus two Complex numbers
try:  # This will give error, so I must put in try-except statement
    print(a + b)
except TypeError:
    print("unsupported operand type(s) for +: 'Complex' and 'Complex'") 
```
::: -->

## Representing objects as Strings

- The `.__str__()` special method returns a human-readable string representation of the object. 
    - Python calls this method when we call the built-in `str()` function, passing an instance of the class as an argument.
    - Python also calls this method when we use the instance as an argument to `print()` and `format()` functions.
- The `__repr__()` special method returns a string representation of an object that's targeted at the developer.
    - Ideally, the returned string should be crafted in such a way that you can construct an identical instance of the object from the string.
    - Python calls this method when we call the built-in `repr()` function, passing an instance of the class as an argument.
    - In interactive mode or Jupyter Notebook, this method will be called when we querry the object **WIHTOUT** using function `print()`.

> At this point, I illustrate the difference between `__str__()` and `__repr__()` using NumPy object.

## Representing objects as strings: NumPy example

::: {.fragment}
- Look at this NumPy example
```{python}
import numpy as np
a = np.array([1, 2, 3, 4, 5])
b = np.array([1.1, 2.1, 3.1, 4.1, 5.1])
print(a + b)    # this print out a string
str(a + b)      # returns a string that is printed out by the function print
```
:::

::: {.fragment}
- But, if I write `a + b` in the interactive mode, you see the `array()` wrapping around the list of numbers
```{python}
a + b
```

- In fact, the above output is the string given by
```{python}
repr(a + b) # returns a string
```
:::

## User-friendly representations with `__str__()`
- Let us revisit out `Complex` class
```{python}
class Complex:
    def __init__(self, real=0, imag=0):
        self.real = real
        self.imag = imag

    def __str__(self):
        output = f"{self.real}"
        if self.imag != 0:
            output += f" + {self.imag}*i"
        return output
```

- Now, we can print a `Complex` number using `print()`
```{python}
a = Complex()
b = Complex(1, 0)
c = Complex(4, 2)
print(f"a = {a}, b = {b}, c = {c}")
```

## Developer-friendly representation with `__repr__()`
```{python}
class Complex:
    def __init__(self, real=0, imag=0):
        self.real = real
        self.imag = imag

    def __repr__(self):
        output = f"Complex: {self.real}"
        if self.imag != 0:
            output += f" + {self.imag}*i"
        return output
```

- Now, we can understand better as the output represents an object of `Complex` class:
```{python}
a = Complex(1, 2)
a
```
- We can examine it closely by using `repr()` function:
```{python}
repr(a)
```


## Overriding operators
- At this point, we want to do some operations on the Complex Number: $a = 1 + 2 \mathrm{i},\quad b= 2 + \mathrm{i}\quad \Rightarrow\quad a + b = 3 + 3 \mathrm{i}$
- But we cannot do this by writing **naive** code `a + b` as computer does not understand the concept of Complex numbers. We must teach it how to do such operation.

```{python}
#| error: true
a = Complex(1, 2)
b = Complex(2, 1)
print(a + b)
```


## Arithmetic operations
- Arithmetic operators are those that we use to perform *arithmetic operations* on numeric values. Python represents them with the usual math signs.

| Supporting method | Operation   |
|-------------------|-------------|
| `__add__(self, other)`    | +   |
| `__sub__(self, other)`    | -   |
| `__mul__(self, other)`    | *   |
| `__truediv(self, other)`  | /   |
| `__floordiv(self, other)` | //  |
| `__mod__(self, other)`    | %   |
| `__pow__(self, other)`    | **  |

- Note that all these methods take a second argument called `other`. In most cases, 

## Arithmetic operations
- In fact, arithmetic operations are just functions.
```{python}
def add(a, b):
    return a + b

print(1 + 2)        # An operation acting on two input arguments returns a value.   
print(add(1, 2))    # A function acting on two input arguments returns a value.
```
- In OOP language, we can write  
```{python}
(1).__add__(2)  # Note the parentheses around 1. We cannot write 1.__add__(2)
```  
instead of
```{python}
1 + 2
```

## Overriding addition and subtraction
```{python}
class Complex:
    def __init__(self, real=0, imag=0):
        self.real = real; self.imag = imag
    
    def __add__(self, other):
        if not isinstance(other, type(self)):
            raise TypeError("unsupported operand for +: " 
                            + f"{type(self).__name__} and {type(other).__name__}")
        output = Complex(self.real + other.real, self.imag + other.imag)
        return output

    def __sub__(self, other):
        if not isinstance(other, type(self)):
            raise TypeError("unsupported operand for -: " 
                            + f"{type(self).__name__} and {type(other).__name__}")
        return Complex(self.real - other.real, self.imag - other.imag)
    
    def __str__(self):  # I shorten the code by lazy code
        return f"{self.real} + {self.imag}*i"
```

## Overriding addition and subtraction
- Then, we can do addition and subtraction now:
```{python}
a = Complex(1, 2)
b = Complex(2, 1)
print(f"a + b = {a + b}")
print(f"a - b = {a - b}")
```

- But since we did not define `__repr__(self)` in the above class template, we get in the interactive mode as follows
```{python}
a + b   # in the interactive mode: __repr__(self) will be executed
```
- To fix this issue, we only need to write `__repr__(self)` in the class template.   
<font color="magenta">You should do it as a homework</font>

## Overriding multiplication
- Of course, we want to do multiplications as well
```{python}
#| error: true
a, b = Complex(1, 2), Complex(2, 3)
print(a * b)
print(3.14 * a)
print(a * 3.14)
```

## Overriding multiplication
```{python}
from numbers import Real
class Complex:
    def __init__(self, real=0, imag=0):
        self.real = real; self.imag = imag
    
    def __mul__(self, other):
        if isinstance(other, type(self))==False and isinstance(other, Real)==False:
            raise TypeError("unsupported operand for *: " 
                            + f"{type(self).__name__} and {type(other).__name__}")
        if isinstance(other, type(self)):
            output = Complex(self.real*other.real - self.imag*other.imag, 
                             self.real*other.imag + self.imag*other.real)
            return output
        if isinstance(other, Real):
            output = Complex(other*self.real, other*self.imag)
            return output

    def __str__(self):  # I shorten the code by lazy code
        return f"{self.real} + {self.imag}*i"
```

## Overriding multiplication
- Now we can use the multiplication
```{python}
a, b = Complex(1, 2), Complex(2, 1)
print(f"a * b = {a * b}")
print(f"a * 5 = {a * 5}")       # note that a is on the left-hand side of 5
print(f"a * 5.0 = {a * 5.0}")   # note that a is on the left-hand side of 5.0
```

- But the multiplication between a `float` and a `Complex` has not been defined.   
Note that `a` is on the right-hand side of `5.0`
```{python}
#| error: true
print(5.0 * a)
```

## Overriding right multiplication
```{python}
#| eval: true
#| echo: false
from numbers import Real
class Complex:
    def __init__(self, real=0, imag=0):
        self.real = real; self.imag = imag
    def __mul__(self, other):
        if isinstance(other, type(self))==False and isinstance(other, Real)==False:
            raise TypeError("unsupported operand for *: " 
                            + f"{type(self).__name__} and {type(other).__name__}")
        if isinstance(other, type(self)):
            output = Complex(self.real*other.real - self.imag*other.imag, 
                             self.real*other.imag + self.imag*other.real)
            return output
        if isinstance(other, Real):
            output = Complex(other*self.real, other*self.imag)
            return output
    
    def __rmul__(self, other):
        if isinstance(other, Real)==False:
            raise TypeError("unsupported operand for *: "
                            + f"{type(other).__name__} and {type(self).__name__}")
        output = Complex(other*self.real, other*self.imag)
        return output 

    def __str__(self):  # I shorten the code by lazy code
        return f"{self.real} + {self.imag}*i"
```

```{python}
#| eval: false
class Complex:
    # PREVIOUS CODE AS BEFORE

    # right multiplication
    def __rmul__(self, other):
        if isinstance(other, Real)==False:
            raise TypeError("unsupported operand for *: "
                            + f"{type(other).__name__} and {type(self).__name__}")
        output = Complex(other*self.real, other*self.imag)
        return output
```

- We can multiply a scalar in front of (by) a `Complex` object now:
```{python}
a = Complex(1, 2)
print(5 * a)
print(5.5 * a)
```

- Simiarly, you have <font color="red">**right addition**</font> implemented by  
`__radd__(self, other)`

## Comparison operator methods

| Operator | Supporting method     |
|----------|-----------------------|
| `<`      | `__lt__(self, other)` |
| `<=`     | `__le__(self, other)` |
| `==`     | `__eq__(self, other)` |
| `!=`     | `__ne__(self, other)` |
| `>=`     | `__ge__(self, other)` |  
| `>`      | `__gt__(self, other)` |

- Of course, we cannot say $1 + 2i > 0.5 + 1.5 i$ but we can say $1 + 2i = 1 + 2i$.
- We can define comparison "equal to" and "not equal to" for `Complex` objects.
- So, we can define `__eq__(self, other)` for "equal" comparison `==` and `__ne__(self, other)` for "not-equal" comparison.
