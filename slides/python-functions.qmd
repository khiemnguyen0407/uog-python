---
title: "Functions in Python"
author: |
    Khiem Nguyen 
    <br>Lecturer in Multiscale Materials
    <br><khiem.nguyen@glasgow.ac.uk>
author-meta: "Lecturer in Multiscale Materials"
format: 
    revealjs:
        theme: default
        title-slide-style: pandoc
        echo: true
        code-overflow: wrap
        code-line-numbers: true
        css: style.css
---

# Intended Learning Outcomes

## Intended Learning Outcomes
- Why are the functions used?
- Basic syntax of writing functions in Python
    - doc strings
    - positional arguments
    - default arguments
    - keyword arguments
- Arbitrary number of input arguments

## Why are functions
- We have used functions all the time: `print()`, `max()`, `len()`, etc.
- We need to write our own.

<center><font color="red"> **Why functions** </font> </center>
- Make a program more readable, understandble
- Break down a big problem into many smaller, solvable tasks/problems. These smaller tasks are assembled to solve the original *big* problem.
- Be recycle and reusable

<center><font color="gold"> **Golden Rule** </font> </center>

<center> <span style="font-size: 2.0em;"> 
**Do not reinvent the wheel!** 
</span> </center>

## Function: Syntax
```Python
def function_name(argument1, argument2, argument3, ...):
    """
    Text description: Explain what the function does and the meanings
    of the input arguments and possibly outputs of the function.
    """
    <statement>
    <statement>
    return expression   # optional --> function returns values
```
⭕ Always write text description for function unless it is very short and self-explanatory.

## Function: Doc string
```{python}
def call_me_maybe(number):
    """
    This function is inspired by a famous song.
    This second line explains absolutely nothing.
    """
    print(f"Call me via number {number}")
```
⭕ Use **question mark** to request function's doc string -- This slide does not show the output.
```{python}
call_me_maybe?
```
⭕ Illustration by live coding at this point.

## Function: Example
```{python}
def cat_age_to_human_age(cat_age):
    """Translate cat age to human age."""
    multiplier = 4
    if (cat_age == 1): 
        return 15
    if (cat_age == 2): 
        return 24
    return cat_age * multiplier + 16
```

After the function is defined, we can call them by:
```{python}
my_age = 46
cat_age_to_human_age(12)  # pointless, ignores answer
felix_age = cat_age_to_human_age(4)     # felix_age = 32
print(cat_age_to_human_age(12))         # very old
```

## Call a function
- As mentioned, every variable in Python is an object. A function is also an object.
```{python}
def greet():
    """Simple function to greet people."""
    print("Hello there!")
```

- We call a function by using parentheses after the function name.

```{python}
# Call the function by:
greet()

# This is a function object - remember: every variable is an object
greet
```
::: {.callout-note}
**Use the parenthesis when calling a function**, not just the name of the function.
:::

## Function: Multiple input arguments

In function definition many input arguments can be declared -- recall the syntax!

```{python}
def print_max(a, b):
    """Print the maximum value between a and b."""
    if a > b:
        print(a)
    else:
        print(b)

# After function definition, we can call it. 
# he function exists but has not been executed to this point.
max(3, 4)           # accept literals, print out 4
fred, anne = 7, 6   # multiple assignments
max(fred, anne)     # accept variables too, print out 7
```



::: {.fragment}
- In this example, the order of the variables `a` and `b` is not important as they carry the same meaning.
:::
::: {.fragment}
- Question: Can you give me an example in which the positions of the input arguments are important?
:::


## Function: **positional* arguments
- Solve a linear equation $a x + b = 0$
```{python}
def solve_linear_equation(a, b):
    """Solve equation a x + b = 0 for x"""
    if a != 0:
        return -b/a
    else:
        if b == 0:
            print("Equation has infinite number of solutions.")
        else:
            print("Equation does not have solution.")
```

::: {.fragment}
- Question: What happens and what is the return of this function when $a = b = 0$?
::: 

## Function: **positional** arguments
- Use of the function `solver_linear_equation()`
```{python}
print("Solve equation 2 x + 1 = 0:", solve_linear_equation(2, 1))
print("Solve equation   x + 2 = 0:", solve_linear_equation(1, 2))
print("Solve equation   x     = 0:", solve_linear_equation(1, 0)) 
print("Solve equation 0 x + 1 = 0:", solve_linear_equation(0, 1))  
```

::: {.fragment}
- Question: How can we remember the meanings of all the input arguments if the function needs a long list of arguments?
:::

::: {.fragment}
- Answer: Use of **keyword** argument. We can specify which argument takes which value.
:::

## Keyword arguments
```{python}
def solve_linear_equation(a, b):
    """Solve equation a x + b = 0 for x"""
    if a != 0:
        return -b/a
    else:
        if b == 0:
            print("Equation has infinite number of solutions.")
        else:
            print("Equation does not have solution.")
```

::: {.fragment}
- Functions can also be called using keyword arguments of the form

<center> `kwarg=value` </center> 
```{python}
# These two lines of code are equivalent
# as we have assigned a and b to the same set of values.
print("Solve equation 2 x + 1 = 0:", solve_linear_equation(b=1, a=2)) 
print("Solve equation 2 x + 1 = 0:", solve_linear_equation(2, 1))
```
:::

## Keyword arguments: further explanation

- We may normally see function calls that look like this
<center> `function(a=a, b=b, c=c, ...)` </center>
In this function call, the variables on the right-hand side of assignment sign "=" provide the values to the input arguments with the names as indicated on the left-hand side.

```{python}
v1, v2 = 2, 1
print("Solve equation 2 x + 1 = 0:", solve_linear_equation(a=v1, b=v2))

a, b = 2, 1
# In the writing "a=a" and "b=b", the keyword arguments 
# "a=" and "b=" mean that a and b expect to receive values 
# while the actual values are given on the right-hand sides 
# of a and b.
print("Solve equation 2 x + 1 = 0:", solve_linear_equation(b=b, a=a))
```

::: {.fragment}
- Question: Can you name any scenario that may need a lot of input arguments and thus the use of keyword arguments will benefit such cases?
:::

## Brain storm
So let us examine a Newton-Raphson method to solve algebraic equation $f(x) = 0$

![](./figures/python-functions/newton-raphson-method.png)

## Brain storm
![Newton-Raphson iterations](./figures/python-functions/newton-raphson-method.png)

::: {.fragment}
- Question: What happens if don't need to supply values to all the input arguments?
:::
::: {.fragment}
- Answer: Some input arguments may take **default** values if no values are supplied.
    - number of iterations $N_\text{iter}$
    - tolerance $\varepsilon$ for stopping the iterations: $|f(x)| < \varepsilon$
- However, very often we want $N_\text{iter}$ and $\varepsilon$ to be defaulted to some sensible numbers, e.g. $N_\text{iter} = 10^{4}$ and $\varepsilon = 10^{-6}$.
:::

::: {.fragment}
<center> This leads to **default argument values**. </center>
:::

## default argument values

- The argument can take <font color="red">**default value**</font> if the function call does <font color="red">not specify the value for it.</font>

```{python}
# variable "retries" and "reminder" are defaulted to 4 
# and 'Come on!...' 
def ask_ok(prompt, retries=4, reminder='Only "yes" or "no"'):     
    """ Ask until receiving 'yes' or 'no' """
    while True:
        ok = input(prompt)
        if ok in ('y', 'ye', 'yes'):
            return True
        if ok in ('n', 'no', 'nah'):
            return False
        retries = retries - 1
        if retries < 0:
            print(reminder)
            return False # or return None
```

## default argument values
```python
def ask_ok(prompt, retries=4, reminder='Only "yes" or "no"'):     
    """ Ask until receiving 'yes' or 'no' """
    while True:
        ok = input(prompt)
        if ok in ('y', 'ye', 'yes'):
            return True
        if ok in ('n', 'no', 'nah'):
            return False
        retries = retries - 1
        if retries < 0:
            print(reminder)
            return False # or return None
```

- This function can be called in several ways
```python
# By default, reminder = 'Only "yes" or "no"'
ask_ok("Want a Quiz?", retries=2)
# By default, retries = 4, reminder = 'Only "yes" or "no"'
ask_ok("Want another Quiz?")
```

## Scope of variables in functions
- **Scope of variables** is a very complex topic in programming in general, and deserves a separate lecture on its own.
- In general, the topic is about how a part of the program can recognize the variables and up to which space that part cannot see those variables anymore.

::: {.fragment}
- Here, we focus on the scope of variables in using functions.
:::
::: {.fragment}
- We are concerned with two cases:
    - Copy of input argument in functions
    - List as input in functions
:::

## Copy of input argument in functions
```{python}
def tweak(a):
    print(a)        # print a before changing
    a = 20          # assign 20 to a
    print(a)        # print a after changing
    # tweak_output is None -- we talk later about this
```

::: {.fragment}
- Question: What output do you expect from the following code snippet?
```python
x = 10
tweak_output = tweak(x)   
print(x)
print(tweak_output)
```
:::

## Copy of input argument in functions
```{python}
def tweak(a):
    print(a)        # print a before changing
    a = 20          # assign 20 to a
    print(a)        # print a after changing
    # tweak_output is None -- we talk later about this
```

::: {.fragment}
- Answer:
```{python}
x = 10
tweak_output = tweak(x)   
print(x)
print(tweak_output)
```
:::

## Copy of input argument in functions
```{python}
x = 10
tweak_output = tweak(x)   
print(x)
print(tweak_output)
```
**Explanation** 

- The copy of `x` has been made in the function so that the value of `x` does not change after calling `tweak()`. 
- `print(x)` prints `10` because `x` is equal to $10$.
- There is no `return` statement in the function `tweak()`, so the function return `None`. Therefore `tweak_output` takes value `None`.

## List as input in functions: Understanding a list
```python
my_list = ["element 1", "element 2", "element 3"]
list_alias = my_list
print("id(my_list)    =", id(my_list))       
print("id(list_alias) =", id(list_alias))
print("my_list    =", my_list)
print("list_alias =", list_alias)
# Let us change the first element of list_alias
list_alias[0] = "something"
print("After changing list_alias:")
print("my_list    =", my_list)
print("list_alias =", list_alias)
```
- **Question**: What output do you expect to see?

## List as input in functions: Understanding a list
```{python}
my_list = ["element 1", "element 2", "element 3"]
list_alias = my_list
# --> list_alias and my_list point to the same list
print("id(my_list)    =", id(my_list))       
print("id(list_alias) =", id(list_alias))
print("my_list    =", my_list)
print("list_alias =", list_alias)
# Let us change the first element of list_alias
list_alias[0] = "something"
print("After changing list_alias:")
print("my_list    =", my_list)
print("list_alias =", list_alias)
```

## List as input in functions
```{python}
def greeting(names):
    """Say hello to everyone."""
    print("id(input-argument) =", id(names))    # print ID of the input argument
    for name in names:
        print("Hello " + name + "!", end = "\t")
    names[0] = "Somebody else"  # Change the first element of the input-argument (as a list)
    names[-1] = "Stranger"      # Change the last element of the input-argument (as a list)
```

```python
people = ["Fred",  "Anna", "Bob"]       # create a list
print("people (before function call) =", people)    
print("id(people) =", id(people))

print(15*"=" + " Function call " + 15*"=")
greeting(people)                      
print("\n" + 45*"=")

print("people (after function call)  =", people)
```
- **Question**: What output do you expect to see?

## List as input in functions
```{python}
people = ["Fred",  "Anna", "Bob"]       # create a list
print("people (before function call) =", people)    
print("id(people) =", id(people))

print(15*"=" + " Function call " + 15*"=")
greeting(people)                      
print("\n" + 45*"=")

# see the changes after the function call
print("people (after function call)  =", people)    
```

## Function outputs

- Every function (just like in maths) returns one thing, using the `return` statement.
- Even if the function does not return anything, it actually returns with the value `None`.

::: {.fragment}
```{python}
def addition(a, b):
    """Is there a duller function?"""
    return a + b
s = addition(3, 7)      # usage is dull too
print(s)
```
:::

::: {.fragment}
```{python}
def say_hello(name):
    print("Hello", name, "!")

output = say_hello("Khiem")
```
- **Question**: What is the value of output?
::: 

::: {.fragment}
```{python}
print(output)
```
:::

## Function outputs
- To implement many outputs for one function return, we just return a tuple, a list or dictionary. The purpose of the function will usually suggest which one is best.
- Returning a tuple is the most common use.

```{python}
def find_min_max(array):
    min_val, max_val = array[0], array[0]   
    for i in range(1, len(array)):
        if array[i] < min_val:
            min_val = array[i]
        if array[i] > max_val:
            max_val = array[i]
    return min_val, max_val
```
```{python}
min_val, max_val = find_min_max([-1, -4, 3, 5, 2])
print(f"min value = {min_val}")
print(f"max value = {max_val}")
```
- **Note**: Don't use `min` and `max` as variable names; they are functions provided by Python.

## Function outputs

```{python}
def find_min_max(array):
    min_val, max_val = array[0], array[0]   
    for i in range(1, len(array)):
        if array[i] < min_val:
            min_val = array[i]
        if array[i] > max_val:
            max_val = array[i]
    return min_val, max_val
```
::: {.fragment}
- **Question**: What is the code for finding the min and max values of a list $\begin{bmatrix} 1 & 3 & 5 & \ldots & 999 \end{bmatrix}$?
:::

::: {.fragment}
```{python}
find_min_max(list(range(1, 1000, 2)))
```
:::

## Documentation string

- All functions can have text as their first line to explain its functioning.
- This can be a one line or multiple lines.
- Signified by three double quotations on the left and on the right: `"""documentation strings"""`
- By convention, Python uses this as documentation for the function, and the function `help()` to fetches them.#
Instead of `help(function_name)`, we can also use `function_name?`

```{python}
def add(a, b):
    """Is there a duller function?"""
    return a + b
```

## Documentation string
Repeat example

```{python}
def add(a, b):
    """Is there a duller function?"""
    return a + b
```

::: {.fragment}
- The question mark syntax `add?` does not work on this slide but `help(add)` does.
```{python}
help(add)
```
:::

::: {.fragment}
- To use the question mark syntax `add?`, let us turn to Jupyter Notebook (live code illustration).
:::



# Arbitrary number of input arguments

## Variable number of inputs: tuple as inputs

**Syntax**
```python
def function_name(normal_arg1, normal_arg2, ..., *args):
    <statements>
```

- Very often, you might want to have a variable number of inputs to a function -- by convention, these inputs are named in the variable `args`
- The variable `args` will always be a tuple, and is placed as the last argument (still before variable number of inputs as keyword arguments).
- There is no positional arguments after `args`.
- The asterisk `*` in front of `args` is to signify that the tuple is unpacked and passed in as separate arguments. These seprate arguments are then accessed by indexing.

## Variable number of inputs: tuple as inputs

**Example** 

```{python}
def print_out_info(name, age, *args):
    print("Name:", name)
    print("Age:", age)
    print("Gender:", args[0])
    print("Profession:", args[1])
    print("Years of experience:", args[2])
```

Use of this function

```{python}
print_out_info("Khiem", 38, "male", "lecturer", 4)
```

## Arbitrary argument list: Arguments wrapped up in a tuple
**Problem statement** 

- We want to define a function `concat` that joins all the input parameters by a seprator which is defaulted to `"--"`.
- Below are two examples: 
    - The statement `concat("earth", "mars", "venus")`   
    returns the string `earth--mars--venus`.
    - The statement `concat("Mech", "Engineering", "Skills", "3", sep=" ")`  
    returns the string `"Mech Engineering Skills 3"`

- Before defining this function, let us study the method `join` for a string.

```{python}
my_tuple = ("This", "is", "a", "short", "sentence")
my_string = " -- "
print(my_string.join(my_tuple))
```
- **Question**: How can we define the function `concat` as described above?

## Arbitrary argument list: Arguments wrapped up in a tuple

Define a function `concat` receiving arbitrary number of inputs so that

- The statement `concat("earth", "mars", "venus")`   
returns the string `earth--mars--venus`.
- The statement `concat("Mech", "Engineering", "Skills", "3", sep=" ")`  
returns the string `"Mech Engineering Skills 3"`

::: {.fragment}
**Answer**

```{python}
def concat(*args, sep="--"):
    return sep.join(args)
```

```{python}
print(concat("earth", "mars", "venus"))
print(concat("Mech", "Engineering", "Skills", "3", sep=" "))
```
:::

## Arbitrary argument list: Arguments wrapped into a dictionary

**Syntax**
```python
def function_name(..., *args, **kwargs):
    <statements>
```