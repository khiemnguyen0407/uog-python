---
title: "Object-oriented Programming"
subtitle: "Implementation of OOP in Python"
author: |
    Khiem Nguyen 
    <br>Lecturer in Multiscale Materials
    <br><khiem.nguyen@glasgow.ac.uk>
author-meta: "Lecturer in Multiscale Materials"
format: 
    revealjs:
        theme: default
        title-slide-style: pandoc
        echo: true
        code-overflow: wrap
        code-line-numbers: true
        css: style.css
---

# Object-oriented programing
## Concept

> **Object-Oriented Programming** (OOP) is a programming paradigm that organizes software design around objects, which are instances of classes. These objects encapsulate data (attributes) and behavior (methods), making it easier to model real-world entities in code.

<center> <img src='./figures/python-oop/drawing-shapes.png' width="650"> </center>


## Core principles of OOP

1. <span style="font-family:monospace;"><font color="red">**Encapsulation**</font></span>
    - Bundles data and methods that operate on that data into a single unit (class)
    - Protects internal state by controlling access through public/private interfaces.
2. <span style="font-family:monospace;"><font color="red">**Inheritance**</font></span>
    - Allows a class to inherit properties and behaviors from another class.
    - Promotes code reuse and hierarchical relationships.
3. <span style="font-family:monospace;"><font color="red">**Polymorphism**</font></span>
    - Enables objects to be treated as instances of their parent class, even if they have different implementations.
    - Example: Different shapes (Circle, Square) can share a common interface draw().
4. <span style="font-family:monospace;"><font color="red">**Abstraction**</font></span>
    - Hides complex implementation details and exposes only essential features.
    - Helps reduce complexity for the user of the class.


## Why do we need OOP?

- <font color="red">**Modularity**</font>    
    Code is organized into classes, making it easier to maintain and debug.
- <font color="red">**Reusablity**</font>  
    Inheritance and polymorphism allow you to reuse existing code.
- <font color="red">**Scalability**</font>    
    Large systems become easier to manage because functionality is grouped logically.
- <font color="red">**Maintainability**</font>  
    Changes in one part of the system have minimial impact on others
- <font color="red">**Real-world modelling**</font>  
    OOP maps naturally to real-world entities, making design intuitive.

## Procedure Programming
- **Definition**  
    A programming paradigm based on procedures (functions) and sequential executtion of instructions
- **Structure**  
    Code is organized into functions that operate on data, but data and behaviors are separate.
- **Examples**
    C, Pascal, early Python scripts, MATLAB (MATLAB has OOP but OOP in MATLAB is not popular)

## Procedural Programming vs OOP

<font color="red">**Procedure Programming**</font>  

| **Pros** | **Cons** |
|:---------|:---------|
| Simple and easy to learn for small programs | Harder to maintain as codebase grows (spaghettie code risk) |
| Good for tasks that are linear and algorithmic | Poor modelling of real-world entities
| Lower overhead compared to OOP for small-scale projects | Code reuse is limited; duplication (Copy/Paste) is common
| | Changes in data structures often require changes in many functions

## Procedure Programming vs OOP
<font color="red">**Object-oriented programming**</font>

| **Pros** | **Cons** |
|:---------|:---------|
| *Encapsulation*: Keep data and method, improving *moduliarty* | More complex for beginners |
| *Reusuability*: Inheritance and polymorphism reduce duplication | Slightly more overhead (memory and design time)
| *Maintainability*: Easier to update and extend larger systems | Can lead to over-engineering for simple tasks
| *Real-world modelling*: Classes map naturally to entitities | 

:::{.fragment}
<font color="red">**Key Difference**</font>

- **Procedural**: Focuses on *functions* and *procedures* acting on data.

- **OOP**: Focuses on *objects* that encapsulate both data and behavior.
:::


## Objects we have used all the time
- **String**
```{python}
sep = '--'
t = 'Mechanical', 'Engineering', 'Skills', '3'
sep.join(t)
```

- **List**
```{python}
a = [i for i in range(4)]
b = [4 - i for i in range(4)]
print(f"a + b = {a + b}")
```

- **NumPy Arrays**
```{python}
import numpy as np
a = np.array([1, 2, 3, 4])
b = np.array([4, 3, 2, 1])
print(f"a + b = {a + b}")
```

## Objects we have used all the time
```{python}
import matplotlib.pyplot as plt

fig = plt.figure(figsize=(6, 4))  # Creates a Figure object
print(type(fig))  # <class 'matplotlib.figure.Figure'>

ax = fig.add_subplot(111)         # Adds an Axes object
ax.plot([1, 2, 3], [4, 5, 6])
plt.show()
```

## Why do we have to learn OOP in Python?
A lot of Python libraries are written and provided in OOP paradigm.

```{python}
from sklearn.linear_model import LinearRegression # for linear regression
import numpy as np
model = LinearRegression()          # Create a LinearRegression object

# Prepare data for fitting
X = np.array([[1], [2], [3], [4], [5]])     # Features
y = np.array([2, 4, 6, 8, 10])              # Target
# Fit the Linear Regression model to data
model.fit(X, y)                      
# predict new values
predictions = model.predict(np.array([[1.5], [2.5]]))

print(type(model))
print(type(predictions))
print(predictions)
```

## Why do we have to learn OOP in Python?
A lot of Python libraries are written and provided in OOP paradigm.
```{python}
import matplotlib.pyplot as plt
from matplotlib.patches import Circle, Rectangle
fig, ax = plt.subplots(figsize=(4.5, 4.5))
circle = Circle((0.5, 0.5), 0.3, color='skyblue', alpha=0.7)
ax.add_patch(circle)
rect = Rectangle((0.1, 0.1), 0.3, 0.2, color='orange', alpha=0.8)
ax.add_patch(rect)
plt.show()
```


## Class definition syntax
```python
class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
```
> A **Class** is defined by the keyword `class` followed by the name of the class.
>
> Note the colon "**:**" and "**indentation**"

- The statements can define variables
- The statements can define functions
- The statements can implement all sorts of stuff you need to.

## Concept: A gentle introduction
- Template for a **Circle**
```{python}
class Circle:       # class name

    def __init__(self, center_outside, radius_outside): # constructor
        self.center = center_outside        # data
        self.radius = radius_outside        # data

    def draw(self):                         # method
        print("Drawing is done")    # plotting is done here.

    def show_data(self):                    # method
        print(f"Circle: center = {self.center}, radius = {self.radius}")
```
- A **Circle** can be created and used
```{python}
c = Circle(center_outside=(1, 1), radius_outside=0.5)
c.show_data()
c.draw()
```

## Concept: about Constructor
```{python}
c = Circle(center_outside=(1, 1), radius_outside=0.5)
c.show_data()
c.draw()
```
What has just happened

- When the statement `c = Circle((1, 1), 0.5)` is executed, the function `__init__()` is executed. Then, an object is created and assigned the variable `c`.
- The variable `c` now exists and represent an object of type `Circle`.

## Syntax: Example
```{python}
class SimpleClass:
    class_value = 42                # class variable

    def __init__(self, value_outside):      # Constructor
        self.value = value_outside          # object variable

    def say_hello(self):            # method
        print("Hello there!")
```

How to use it
```{python}
print(SimpleClass.class_value)      # value assosicated with the class

object = SimpleClass(24)            # create an object
print(f"object.value = {object.value}")     # value associated with object
object.say_hello()                  # object call "say_hello()"
```

## Syntax: Example - further explanation
- `value_outside` is just a variable name.
- `value` is another *data* associated with the object "self".
- `value_outside` cannot be confused with `self.value` even if its name is changed to `value`.
- The variable "self" will be explained later.

::: {.fragment}
Thus, Python perfectly permits
```{python}
class SimpleClass:
    class_value = 42                # class variable
    def __init__(self, value):      # Constructor
        self.value = value          # object variable
    def say_hello(self):            # method
        print("Hello there!")
```
:::
> This is the **recommended** way of writing a **constructor**.

## Syntax: Questions and Sweets

- How do we write the constructor `__init__()` for the class `Circle` using the recommended practice?
- How can we write a functions to set the center and the radius to new values?

::: {.fragment}
```{python}
class Circle:       # class name

    def __init__(self, center, outside):    # constructor
        self.center = center                # data
        self.radius = radius                # data

    def set_center(self, center):
        self.center = center
    
    def set_radius(self, radius):
        self.radius = radius
```

> Remember: The first argument of every function is `self`.
:::



## Syntax: Example -- further explanation
```{python}
class SimpleClass:
    class_value = 42                # class variable
    def __init__(self, value):      # Constructor
        self.value = value          # object variable
    def say_hello(self):            # method
        print("Hello there!")
```

::: {.fragment}
A simple interpretation of `say_hello()`
```{python}
object.say_hello()              # this works
# This works too: without object argument, it will give error
SimpleClass.say_hello(object)   
try:
    SimpleClass.say_hello()         # Need try to catch the error here!
except:
    print("error detected!")
```
:::

## Interpretation of `self` variable
```{python}
class Student:
    def __init__(self, ID):
        self.ID = ID
    def do_job(self):
        print("I am studying")
    def reveal_ID(self):
        print(self.ID)
```
::: {.fragment}
Create an object
```{python}
khiem = Student(3040787)
print(khiem.ID)             # print ID through the object variable
khiem.reveal_ID()           # print ID through the function call
Student.reveal_ID(khiem)    # This give the same result
```
:::
::: {.fragment}
> - During the process of defining the class `Student`, we cannot create an object and assign it to any variable. We cannot write `khiem.ID` and `khiem.reveal_ID()`.
:::

## Interpretation of `self` variable
```{python}
class Student:
    def __init__(self, ID):
        self.ID = ID
    def do_job(self):
        print("I am studying")
    def reveal_ID(self):
        print(self.ID)
```
::: {.fragment}
> Note
>
> - If `self` is a variable in a function definition, we can actually make use of it in the sytntax `Student.reveal_ID(object)`.
> - In fact, `__init__(self, ID)` is just a function too.
:::


## Interpretation of `self` variable
```{python}
class Student:
    def __init__(self, ID):
        self.ID = ID
    def do_job(self):
        print("I am studying")
    def reveal_ID(self):
        print(self.ID)
```
```{python}
stuart = Student(3000000)   # create Stuart
stuart.reveal_ID()          # shows his ID
```
::: {.fragment}
Questions

- How to change his ID?
- How to reveal his ID using the class name, instead of the object?
:::

## Interpretation of `self` variable
**Questions**:

- How to change his ID?
- How to reveal his ID using the class name, instead of the object?

**Solutions**:

::: {.fragment}
```{python}
stuart.ID = 3456789         # change the object variable
stuart.reveal_ID()          
```
:::

::: {.fragment}
```{python}
stuart.__init__(9876543)    # 've just changed Stuart's ID
Student.reveal_ID(stuart)   # reveal ID using different syntax
```
:::
::: {.fragment}
```{python}
Student.__init__(stuart, 1234567)   # not recommended
stuart.reveal_ID()
```
:::

## Object

Of course, some object of complicated concept needs multiple inputs to be created.

```{python}
class Complex:
    def __init__(self, real=0, imag=0):
        self.real = real
        self.imag = imag
```

```{python}
a = Complex(0, 0)
b = Complex()
c = Complex(0, 1)
```

- <font color="red">**Question**</font>: What does `print(a)`,  `print(b)` and `print(c)` give us?

::: {.fragment}
```{python}
print(a)
print(b)
print(c)
```
:::

## Object

- <font color="red">**Question**</font>: How do we show the complex number in a human-reading form?

::: {.fragment}
We write a method to present the complex number itself.

```{python}
class Complex:
    def __init__(self, real=0, imag=0):
        self.real = real
        self.imag = imag

    def print(self):
        print(f"{self.real} * i + {self.imag}")
```
:::



:::{.fragment}
- <font color="red">**Question**</font>: How do we use this above-defined function?
:::
:::{.fragment}
```{python}
a = Complex(1, 0)
b = Complex(0, 1)
a.print()
b.print()
```
:::

## Documentation string
We can write doc strings for class and its methods (functions).
```{python}
class Car():
    """Model a Car."""
    def __init__(self, make, model):
        """
        The constructor receives the producer and model of the car.
        """
        self.make = make        
        self.model = model
        self.tank_cap = 60    # 60 liter tank
        self.tank = 0         # initial fuel tank is empty
    def fill_up(self):
        """Fill the tank to full."""
        self.tank = self.tank_cap
        print("Fill up done: Full!")
```
```{python}
my_car = Car("Nissan", "Micra")
my_car.fill_up()
print(my_car.tank)
```

# Class variables and class methods

## Class variables and class methods
**Syntax**
```python
class ClassName:
    class_variable_1 = 0        # it can have any values
    class_variable_2 = 0        
    ...

    @classmethod
    def class_method(cls):
        <statement-1>
        .
        .
        .
        <statement-N>
```

## Class variables and class methods: Example

**Example**

```{python}
class Car:
    number_of_cars = 0
    def __init__(self, make, model):
        """ Constructor receives producer and model of the car"""
        Car.number_of_cars += 1
        self.make = make
        self.model = model
        self.tank_cap = 60
        self.tank = 0
    def fill_up(self):
        self.tank = self.tank_cap
    @classmethod
    def how_many(cls):
        # 'self' for "object". By convention, we use 'cls' for "class".
        print(f"Number of cars = {cls.number_of_cars}")
```

## Class variables and class methods: Example
```{python}
print(f"Number of cars (using class variable) = {Car.number_of_cars}")

my_car = Car("Nissan", "Micra")
print(f"Number of cars = {Car.number_of_cars}")

your_car = Car("Mercedes", "A160")
print(f"Number of cars = {Car.number_of_cars}")

his_car = Car("Mercedes", "A140")
print(f"Number of cars = {Car.number_of_cars}")

her_car = Car("BMW", "B160")
print(f"Number of cars = {Car.number_of_cars}")
```

## Factory functions using class method
- We can use the class method to create an object.

```{python}
class Pizza:
    def __init__(self, ingredients):
        self.ingredients = ingredients
    
    @classmethod
    def margherita(cls):
        return cls(["mozzarella", "tomatoes"])
```

```{python}
my_pizza = Pizza(["cheese", "cheese", "cheese", "cheese"])
print(my_pizza.ingredients)

your_pizza = Pizza.margherita()
print(your_pizza.ingredients)
```
::: {.fragment}

## Special functions in class
```{python}
print(my_pizza)
print(your_pizza)
```
:::
