---
title: "Object-oriented Programming"
subtitle: "Implementation of OOP in Python"
author: |
    Khiem Nguyen 
    <br>Lecturer in Multiscale Materials
    <br><khiem.nguyen@glasgow.ac.uk>
author-meta: "Lecturer in Multiscale Materials"
format: 
    revealjs:
        theme: dark   # other themes: beige, blood, dark, dracula, league, moon, night, serif, simple, sky, solarized
        slide-number: true
        title-slide-style: pandoc
        echo: true
        code-overflow: wrap
        code-line-numbers: true
        code-block-bg: false          # <-- remove white background in code blocks
        # code-block-border-left: false # optional: remove left border
        # highlight-style: monokai      # good for dark images
        toc: true
        toc-depth: 1
        toc-title: Presentation Outline
        css: simple.css
---

# Object-oriented programing: Principles and Rationale
## Concept

> **Object-Oriented Programming** (OOP) is a programming paradigm that organizes software design around objects, which are instances of classes. These objects encapsulate data (attributes) and behavior (methods), making it easier to model real-world entities in code.

<center> <img src='./figures/python-oop/drawing-shapes.png' width="650"> </center>


## Core principles of OOP

1. <span style="font-family:monospace;"><font color="red">**Encapsulation**</font></span>
    - Bundles data and methods that operate on that data into a single unit (class)
    - Protects internal state by controlling access through public/private interfaces.
2. <span style="font-family:monospace;"><font color="red">**Inheritance**</font></span>
    - Allows a class to inherit properties and behaviors from another class.
    - Promotes code reuse and hierarchical relationships.
3. <span style="font-family:monospace;"><font color="red">**Polymorphism**</font></span>
    - Enables objects to be treated as instances of their parent class, even if they have different implementations.
    - Example: Different shapes (Circle, Square) can share a common interface draw().
4. <span style="font-family:monospace;"><font color="red">**Abstraction**</font></span>
    - Hides complex implementation details and exposes only essential features.
    - Helps reduce complexity for the user of the class.


## Why do we need OOP?

- <font color="red">**Modularity**</font>    
    Code is organized into classes, making it easier to maintain and debug.
- <font color="red">**Reusablity**</font>  
    Inheritance and polymorphism allow you to reuse existing code.
- <font color="red">**Scalability**</font>    
    Large systems become easier to manage because functionality is grouped logically.
- <font color="red">**Maintainability**</font>  
    Changes in one part of the system have minimial impact on others
- <font color="red">**Real-world modelling**</font>  
    OOP maps naturally to real-world entities, making design intuitive.

## Procedure Programming
- **Definition**  
    A programming paradigm based on procedures (functions) and sequential executtion of instructions
- **Structure**  
    Code is organized into functions that operate on data, but data and behaviors are separate.
- **Examples**
    C, Pascal, early Python scripts, MATLAB (MATLAB has OOP but OOP in MATLAB is not popular)

## Procedural Programming vs OOP

<font color="red">**Procedure Programming**</font>  

| **Pros** | **Cons** |
|:---------|:---------|
| Simple and easy to learn for small programs | Harder to maintain as codebase grows (spaghettie code risk) |
| Good for tasks that are linear and algorithmic | Poor modelling of real-world entities
| Lower overhead compared to OOP for small-scale projects | Code reuse is limited; duplication (Copy/Paste) is common
| | Changes in data structures often require changes in many functions

## Procedure Programming vs OOP
<font color="red">**Object-oriented programming**</font>

| **Pros** | **Cons** |
|:---------|:---------|
| *Encapsulation*: Keep data and method, improving *moduliarty* | More complex for beginners |
| *Reusuability*: Inheritance and polymorphism reduce duplication | Slightly more overhead (memory and design time)
| *Maintainability*: Easier to update and extend larger systems | Can lead to over-engineering for simple tasks
| *Real-world modelling*: Classes map naturally to entitities | 

:::{.fragment}
<font color="red">**Key Difference**</font>

- **Procedural**: Focuses on *functions* and *procedures* acting on data.

- **OOP**: Focuses on *objects* that encapsulate both data and behavior.
:::


## Why OOP in Python: We have used it all the time.

**Objects** we have used all the time

- **String**
```{python}
sep = '--'
t = 'Mechanical', 'Engineering', 'Skills', '3'
sep.join(t)
```

- **List**
```{python}
a = [i for i in range(4)]
b = [4 - i for i in range(4)]
print(f"a + b = {a + b}")
```

## Why OOP in Python: We have used it all the time.

- **Figure** and **Axe** objects
```{python}
import matplotlib.pyplot as plt
fig = plt.figure(figsize=(5, 3)) # Creates a Figure object
print(type(fig))      # <class 'matplotlib.figure.Figure'>
ax = fig.add_subplot(111)        # Adds an Axes object
ax.plot([1, 2, 3], [4, 5, 6])
plt.show()
```
## Why OOP in Python
A lot of Python libraries are written and provided in OOP paradigm.

- **NumPy Arrays**
```{python}
import numpy as np 
a = np.array([1, 2, 3, 4])
b = np.array([4, 3, 2, 1])
print(f"a + b = {a + b}")
```

## Why OOP in Python
- **Linear Regression Models**
```{python}
from sklearn.linear_model import LinearRegression # for linear regression
import numpy as np
model = LinearRegression()          # Create a LinearRegression object
# Prepare data for fitting
X = np.array([[1], [2], [3], [4], [5]])     # Features
y = np.array([2, 4, 6, 8, 10])              # Target
# Fit the Linear Regression model to data
model.fit(X, y)                      
# predict new values
predictions = model.predict(np.array([[1.5], [2.5]]))
print(type(model))
print(type(predictions))
print(predictions)
```

## Why OOP in Python
- **Circle** and **Rectangle** from `matplotlib.patches`
```{python}
import matplotlib.pyplot as plt
from matplotlib.patches import Circle, Rectangle
fig, ax = plt.subplots(figsize=(3.5, 3.5))
circle = Circle((0.5, 0.5), 0.3, color='skyblue', alpha=0.7)
ax.add_patch(circle)
rect = Rectangle((0.1, 0.1), 0.3, 0.2, color='orange', alpha=0.8)
ax.add_patch(rect)
plt.show()
```

## Why OOP: A pratical point of view

Last but not least, you will deal with OOP all the time in advanced courses

- <font color="orange">**ENG3091**</font>&nbsp; Advanced Programming and Software Engineering
- <font color="orange">**ENG4200**</font>&nbsp; Introduction to Artificial Intelligence and Machine Learning
- <font color="orange">**ENG5337**</font>&nbsp; Advanced Artificial Intelligence and Machine Learning

# Syntax and Concept

## Concept: Class vs Objects
![](./figures/python-oop/cookie-cutter-class-vs-object.jpg)

## Syntax: Class definition
```python
class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
```
> A **Class** is defined by the keyword `class` followed by the name of the class.
>
> Note the colon "**:**" and "**indentation**"

- The statements can define variables
- The statements can define functions
- The statements can implement all sorts of stuff you need to.

## Concept: A gentle introduction
- Template for a **Circle**
```{python}
class Circle:       # <---- class name

    def __init__(self, center_outside, radius_outside): # constructor
        self.center = center_outside # <-- data, local to each object
        self.radius = radius_outside # <-- data, local to each object

    def draw(self):                  # <---- method
        print("Drawing is done")     # plotting is done here.
    def show_data(self):             # <---- method
        print(f"Circle: center={self.center}, radius={self.radius}")
```

## Concept: A gentle introduction
```{python}
class Circle:       # <---- class name
    def __init__(self, center_outside, radius_outside): # constructor
        self.center = center_outside # <-- data, local to each object
        self.radius = radius_outside # <-- data, local to each object
    def draw(self):                  # <---- method
        print("Drawing is done")     # plotting is done here.
    def show_data(self):             # <---- method
        print(f"Circle: center={self.center}, radius={self.radius}")
```
- A **Circle** can be created and used
```{python}
shit = Circle(center_outside=(1, 1), radius_outside=0.5) # create an object
shit.show_data()   # execute method "show_data" of object "c"
shit.draw()        # execute method "draw" of object "c"
```

## Terminology: Object, Attribute, and Method
- Each object is said "an instance of a particular class".
- Variables associated with objects are known as <font color="red">**attributes**</font>, <font color="red">**members**</font>, or <font color="red">**properties**</font> (depending on the community you are talking to)
- Functions associated with objects are known as <font color="red">**methods**</font>.


## Concept: About Constructor
```{python}
circ = Circle(center_outside=(1, 1), radius_outside=0.5)
circ.show_data()
circ.draw()
```
::: {.fragment}
What has just happened

- When the statement `c = Circle((1, 1), 0.5)` is executed, the function `__init__()` is executed. 
- Right after that, an object of data tyle `Circle` is created and assigned the variable `c`.
- The variable `c` now exists and represent an object of type `Circle`.
:::

::: {.fragment}
`__init__(self, ...)` is the constructor for the class `Circle`.
:::

## Concept: Simple example
```{python}
class SimpleClass:
    class_value = 42                # class variable

    def __init__(self, value_outside):      # Constructor
        self.value = value_outside          # object variable

    def say_hello(self):            # method
        print("Hello there!")
```

How to use it
```{python}
print(SimpleClass.class_value)      # value assosicated with the class

object = SimpleClass(24)            # create an object
print(f"object.value = {object.value}")     # value associated with object
object.say_hello()                  # object call "say_hello()"
```

## Syntax: Example - further explanation
- `value_outside` is just a variable name.
- `value` is another *data* associated with the object "self".
- `value_outside` cannot be confused with `self.value` even if its name is changed to `value`.
- The variable "self" will be explained later.

::: {.fragment}
Thus, Python perfectly permits
```{python}
class SimpleClass:
    class_value = 42                # class variable
    def __init__(self, value):      # Constructor
        self.value = value          # object variable
    def say_hello(self):            # method
        print("Hello there!")
```
:::
> This is the **recommended** way of writing a **constructor**.

## Syntax: Questions and Sweets

- How do we write the constructor `__init__()` for the class `Circle` using the recommended practice?
- How can we write a functions to set the center and the radius to new values?

::: {.fragment}
```{python}
class Circle:       # class name

    def __init__(self, center, outside):    # constructor
        self.center = center                # data
        self.radius = radius                # data

    def set_center(self, center):
        self.center = center
    
    def set_radius(self, radius):
        self.radius = radius
```

> Remember: The first argument of every function is `self`.
:::

## Syntax: Example -- further explanation
```{python}
class SimpleClass:
    class_value = 42                # class variable
    def __init__(self, value):      # Constructor
        self.value = value          # object variable
    def say_hello(self):            # method
        print("Hello there!")
```

::: {.fragment}
A simple interpretation of `say_hello()`
```{python}
object.say_hello()              # this works
# This works too: without object argument, it will give error
SimpleClass.say_hello(object)   
try:
    SimpleClass.say_hello()         # Need try to catch the error here!
except:
    print("error detected!")
```
:::

## Interpretation of `self` variable
```{python}
class Student:
    def __init__(self, ID):
        self.ID = ID
    def do_job(self):
        print("I am studying")
    def reveal_ID(self):
        print(self.ID)
```
::: {.fragment}
Create an object
```{python}
khiem = Student(3040787)
print(khiem.ID)             # print ID through the object variable
khiem.reveal_ID()           # print ID through the function call
Student.reveal_ID(khiem)    # This give the same result
```
:::

::: {.fragment}
> - During the process of defining the class `Student`, we cannot create an object and assign it to any variable. We cannot write `khiem.ID` and `khiem.reveal_ID()`.
:::

## Interpretation of `self` variable
```{python}
class Student:
    def __init__(self, ID):
        self.ID = ID
    def do_job(self):
        print("I am studying")
    def reveal_ID(self):
        print(self.ID)
```
::: {.fragment}
> Note
>
> - If `self` is a variable in a function definition, we can actually make use of it in the sytntax `Student.reveal_ID(object)`.
> - In fact, `__init__(self, ID)` is just a function too.
:::


## Interpretation of `self` variable
```{python}
class Student:
    def __init__(self, ID):
        self.ID = ID
    def do_job(self):
        print("I am studying")
    def reveal_ID(self):
        print(self.ID)
```
```{python}
stuart = Student(3000000)   # create Stuart
stuart.reveal_ID()          # shows his ID
```
::: {.fragment}
<font color="red">**Questions**</font>

- How to change his ID?
- How to reveal his ID using the class name, instead of the object?
:::

## Interpretation of `self` variable
**Questions**:

- How to change his ID?
- How to reveal his ID using the class name, instead of the object?

**Solutions**:

::: {.fragment}
```{python}
stuart.ID = 3456789         # change the object variable
stuart.reveal_ID()          
```
:::

::: {.fragment}
```{python}
stuart.__init__(9876543)    # 've just changed Stuart's ID
Student.reveal_ID(stuart)   # reveal ID using different syntax
```
:::

::: {.fragment}
```{python}
Student.__init__(stuart, 1234567)   # not recommended
stuart.reveal_ID()
```
:::

## Interpretation of `self` variable
- Recall that in the declaration  
```{python}
def do_useless(*args, **kwargs):
    """args and kwargs can take different names"""
    print(args, kwargs)

do_useless(1, 2, 3, one=1, two=2, three=3)
```  
both `args` and `kwargs` can take different variables.
```{python}
def do_useless(*stuffs, **things):
    """This function works as above. Just different argument names"""
    print(stuffs, things)

do_useless(1, 2, 3, one=1, two=2, three=3)
```

## Interpretation of `self` variable
- In the same way, `self` is just the first argument in *functions* declared in a class. It can take different names.
```{python}
class Student:
    def __init__(this, ID): # this is the first argument
        this.ID = ID
    def reveal_ID(that):    # that is the first argument
        print(that.ID)
    def do_job(self):       # you can even mix self and this
        print(f"{self.ID} is studying.")
```
```{python}
Khiem = Student(42424242)
Khiem.do_job()
```
> By convention, always use `self` please

## Object

Of course, some object of complicated concept needs multiple inputs to be created.

```{python}
class Complex:
    def __init__(self, real=0, imag=0):
        self.real = real
        self.imag = imag
```

```{python}
a = Complex(0, 0)
b = Complex()
c = Complex(0, 1)
```

- <font color="red">**Question**</font>: What does `print(a)`,  `print(b)` and `print(c)` give us?

::: {.fragment}
```{python}
print(a)
print(b)
print(c)
```
:::

## Object

- <font color="red">**Question**</font>: How do we show the complex number in a human-reading form?

::: {.fragment}
We write a method to present the complex number itself.

```{python}
class Complex:
    def __init__(self, real=0, imag=0):
        self.real = real
        self.imag = imag

    def print(self):
        print(f"{self.real} * i + {self.imag}")
```
:::

:::{.fragment}
- <font color="red">**Question**</font>: How do we use this above-defined function?
:::

:::{.fragment}
```{python}
a = Complex(1, 0)
b = Complex(0, 1)
a.print()
b.print()
```
:::

## Documentation string
We can write doc strings for class and its methods (functions).
```{python}
class Car():
    """Model a Car."""
    def __init__(self, make, model):
        """
        The constructor receives the producer and model of the car.
        """
        self.make = make        
        self.model = model
        self.tank_cap = 60    # 60 liter tank
        self.tank = 0         # initial fuel tank is empty
    def fill_up(self):
        """Fill the tank to full."""
        self.tank = self.tank_cap
        print("Fill up done: Full!")
```
```{python}
my_car = Car("Nissan", "Micra")
my_car.fill_up()
print(my_car.tank)
```

# Class variables and class methods

## Concept: class variables and class methods
- A class may also have its own status and thus its own attributes and methods.
- A **class variable** is defined in a class and intended to be modified at class level. There is no need of an object to use these attributes.
- A **class method** is defined in a class and indented to be used at class level. We can use class methods even without creating an object.
```python
class ClassName:
    class_variable_1 = 0        # it can have any values
    class_variable_2 = 0        
    ...

    @classmethod                # to define class methods
    def class_method(cls):
        <statement-1>
        ...
        <statement-N>
```

## Class variables and class methods: Example

```{python}
class Car:
    number_of_cars = 0
    def __init__(self, make, model):
        """ Constructor receives producer and model of the car"""
        Car.number_of_cars += 1
        self.make = make
        self.model = model
        self.tank_cap = 60
        self.tank = 0
    def fill_up(self):
        self.tank = self.tank_cap
    @classmethod
    def how_many(cls):
        # 'self' for "object". By convention, we use 'cls' for "class".
        print(f"Number of cars = {cls.number_of_cars}")
```

## Class variables and class methods: Example

```{python}
print(f"Number of cars (using class variable) = {Car.number_of_cars}")

my_car = Car("Nissan", "Micra")
print(f"Number of cars = {Car.number_of_cars}")
your_car = Car("Mercedes", "A160")
print(f"Number of cars = {Car.number_of_cars}")
his_car = Car("Mercedes", "A140")
print(f"Number of cars = {Car.number_of_cars}")

# Finally, we can also ask
print("Finally, we can also ask: ", end="")
Car.how_many()
```

## Factory functions using class method

- We can use the class method to create an object.
```{python}
class Pizza:
    def __init__(self, ingredients):
        self.ingredients = ingredients
    
    @classmethod
    def margherita(cls):
        return cls(["mozzarella", "tomatoes"])
```
::: {.fragment}
```{python}
my_pizza = Pizza(["cheese", "cheese", "cheese", "cheese"])
print(my_pizza.ingredients)

your_pizza = Pizza.margherita()
print(your_pizza.ingredients)
```
:::

## Special functions in class
```{python}
print(my_pizza)
print(your_pizza)
```

# Inheritance & Composition

## Concept: Composition and Inheritance
- **Composition**
    - **Object composition**: Objects can contain other objects in their instance variables.
    - *Object composition* is used to represent <u><font color="red">**has-a**</font></u> relationships.

    <u> *Example*</u>: Every Student has an ID (number), email (string), courses & grades (Table)

```{python}

```
- **Inheritance**
    - Programming languages that support classes always support <font color="red">**inheritance**</font>.
    - Inheritance allows classes to be arranged in a hierarchy that represents <u>is-a-type-of</u> relationships.

    <u>*Example*</u>  
    - A Rectangle is a Polygon, a Circle is an Ellipse. Rectangle, Polygon, Circle and Ellipse are all Shapes.
    - A PhD Student is a Student, a Lecturer is a Staff.

Although we briefly touch *composition*, we shall focus on **inheritance**.

## Composition
Objects can contain other objects as its attributes.
```{python}
class Engine:
    def __init__(self, horsepower):
        self.horsepower = horsepower

    def start(self):
        print(f"Engine with {self.horsepower} HP is starting...")

class Car:
    def __init__(self, make, model, engine):
        self.make = make
        self.model = model      
        self.engine = engine    # Composition: Car has an Engine

    def start(self):
        print(f"Starting car: {self.make} {self.model}")
        self.engine.start()
```

## Composition
```{python}
class Engine:
    def __init__(self, horsepower):
        self.horsepower = horsepower
    def start(self):
        print(f"Engine with {self.horsepower} HP is starting...")

class Car:
    def __init__(self, make, model, engine):
        self.make, self.model, self.engine = make, model, engine # To save space
    def start(self):
        print(f"Starting car: {self.make} {self.model}")
        self.engine.start()
```

::: {.fragment}
```{python}
engine = Engine(horsepower=300)
my_car = Car(make="Toyota", model="Supra", engine=engine)
my_car.start()
```
:::

## Inheritance: Concept and Example

<u>Repeat</u>: **Inheritance** allows classes to be arranged in a hierarchy that represents <font color="red">**is-a-type-of**</font> relationship.



::: {.fragment}
- Let us assume the following scenario:
    - A lecturer is an employee.
    - A member of teaching office (MTO) is an employee.
    - A technician is an employee.
    - A security guard is an employee.
:::

::: {.fragment}
- Then, think of this scenario a bit:
    - All these people have in common the personal information: Full Name, Age, Salary, Employee ID, etc.
    - A lecturer teaches and does research. An MTO prepares course info, inputs grades. A technician does instruction, makes demonstration. A guard looks after people.
:::

## Inheritance: Concept and Example

<font color="blue">**Example**</font>&nbsp;&nbsp;&nbsp;**Drawing here on iPad.**

- The class `Employee` might define variables `full_name`, `age`, `salary`, `ID`, and define the methods `record_name()`, `register_ID()`, `receive_salary()`.
- We can decdie all the classes `Lectuer`, `TeachingOfficeMember`, `Technician` and `SecurityGuard` can inherit from the class `Employee`. Then, these classes inherit all the attributes and methods defined in `Employee`.

> <font color="blue">**Principle benefits**</font>
>
> 1. Inheritance allows easy **reuse** of the procedures, functions, and data definitions.
> 2. New classes can extend the existing classes.

This mechanism mirrors real-world relationships in an intuitive way. Rather than utilizing database tables, and programming subroutines, the developer defines objects that the users are more familiar with in real life.

## Inheritance: Concept and Example

![UML Diagram](./figures/python-oop/uml-employee.png)


## Inheritance: Terminology
Let us assume the following relationship:  <u>class `A` is a type of class `B`</u>.

We can say: 

- class `A` **inherits** class `B`
- class `A` is **derived from** class `B`

<u>**Terminology**</u>&nbsp;&nbsp;&nbsp; We can call

- class `A`:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **derived class** / **super class** / **child class**
- class `B`:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; **base class** / **subclass** / **parent class**

In fact, the names are already self-explanatory in the child-parent relationship.


## Inheritance: Syntax

```python
class DerivedClassName(BaseClassName):
    <statement-1>
    .
    .
    .
    <statement-N>
```
> Remark
>
> - The name `BaseClassName` must be defined in a scope containing the derived class definition.
> - In other words, the `DerivedClassName` must understand `BaseClassName` before it can be defined as its child.

> **Multiple inheritance**: One class can be derived from many classes. Discuss later!!

## Inheritance: Trash example

::: {.fragment}
- Waste Paper is a type of Trash
- Can is a type of Trash
- Trash can be shreaded or burnt.
:::

::: {.fragment}
But:

- Waste Paper has conditions Can does not have and vice versa.
- Both Can and Waste Paper can be crushed but they are crushed differently -- Can need more effort using machines.
:::

::: {.fragment}
Later, down the road we may want to add

- Carton is a type of Trash
- Plastic Box is a type of Trash
- Metal Box is a type of Trash
- etc.
<<<<<<< Updated upstream
:::

## Code 
```{python}
class Trash:
    
    def __init__(self, weight, value):
        """Initialize a Trash instance."""
        self.weight = weight
        self.value = value
        print("Trash constructor: Trash({0}, {1})".
              format(self.weight, self.value))
    
    def shread(sef):
        print("In Trash: Shred me please!")
        
    def burn(self):
        print("In Trash: Burn me please!")
```

## Code: WastePaper and Can
```{python}
class WastePaper(Trash):
    def __init__(self, weight, value, condition, value_wet, value_dry):
        super().__init__(weight, value)
        self.condition = condition
        self.value_wet = value_wet
        self.value_dry = value_dry
        print("WasePaper constructor: WastePaper({0}, {1}, {2}, {3}, {4})".
              format(self.weight, self.value, self.condition, self.value_dry, self.value_wet))
        
    def value_refresh(self):
        self.value_wet = 0
        self.value_dry = 0
```

## Code: WastePaper and Can
```{python}
class Can(Trash):
    def __init__(self, weight, value):
        super().__init__(weight, value)
        print("Can constructor: Can({0}, {1})".
              format(weight, value))
        
    def crush(self):
        print("In Can: Crush me please!")
```

## Code: Use of these objects
```{python}
my_trash = Trash(0.1, 1); print(50*"-")

# Inside the constructor of WastePaper, the constructor of Trash 
# is called explicitly. Then, the rest in 
# WastePaper.__init__ is executed.
my_waste_paper = WastePaper(0.2, 1, "new", 0.8, 0.2)
print("my_waste_paper.weight =", my_waste_paper.weight)  
print("my_waste_paper.value =", my_waste_paper.value)
my_waste_paper.shread(); print(50*"-")
# Similarly, the constructor of Trash is called 
# inside the constructor of Can.
my_can = Can(0.2, 2.0)
my_can.crush()
```

## Overriding
One of important and excited feature of inheritance is that the subclassses can ***override*** the methods defined by superclasses (base class).

```{python}
class Trash:
    def __init__(self, weight, value):
        """Initialize a Trash instance."""
        self.weight = weight
        self.value = value
        print("Trash constructor: Trash({0}, {1})".
              format(self.weight, self.value))
    
    def shread(sef):
        print("In Trash: Shred me please!")
        
    def burn(self):
        print("In Trash: Burn me please!")
    
    # We shall override this method of Trash
    def crush(self):
        print("In Trash: Crush me please!")
```

## Overriding

```{python}
class WastePaper(Trash):
    def __init__(self, weight, value, condition, value_wet, value_dry):
        super().__init__(weight, value)
        self.condition = condition
        self.value_wet = value_wet
        self.value_dry = value_dry
        print("WasePaper constructor: WastePaper({0}, {1}, {2}, {3}, {4})".
              format(self.weight, self.value, self.condition, self.value_dry, self.value_wet))
        
    def value_refresh(self):
        self.value_wet = 0
        self.value_dry = 0
        
    def crush(self):
        print("In WastePaper: Crush me please!")
```

## Overriding

```{python}
class Can(Trash):
    def __init__(self, weight, value):
        super().__init__(weight, value)
        print("Can constructor: Can({0}, {1})".
              format(weight, value))
        
    def crush(self):
        print("In Can: Crush me please!")
        
class GoldDummyCan(Trash):
    
    def __init__(self, weight, value):
        super().__init__(weight, value)
        print("GoldDummyCan constructor: GoldDummyCan({0}, {1}) -- I am rich too!".
              format(weight, value))
        
    def crush(self):
        super().crush()
        print("In GoldDummyCan: Crush me please!")
```

## Override

```{python}
# External code outside the above classes
my_trash = Trash(0.1, 1)
my_trash.crush(); print(50*"-")
my_can = Can(0.2, 2.0)
my_can.crush(); print(50*"-")
his_waste_pp = WastePaper(0.02, 0.2, "old", 0.05, 0.15)
his_waste_pp.crush(); print(50*"-")
your_can = GoldDummyCan(0.05, 200)
your_can.crush()
```

# Special methods/Dunder methods
- Learn what Python's **special methods** (**dunder methods** or **magic methods**) are.
- Understand the magic behind magic methods in Python
- Customize different behaviors of your custom classes with **special methods**

## Dunder methods: Introduction
- A special method is a method whose name starts and ends with a double underscore.
- You already learned one of them: `__init__(self, ...)` is a constructor.
- These sepcial methods are known as **magic methods** or **dunder methods**
- The *double underscores** flag these methods as core to some Python features.

Some popular and well-known magic methods:

| Magic Method | Description |
|---|---|
|`__init__()` | Provides an initializer in Python classes |
|`__str__()` | Provide human-read representation for objects |
|`__repr__()` | Provide developer point-of-view representation |
|`__call__()` | Makes instances of a class callable |
|`__len__()` | Supports the `len()` functioclearn |