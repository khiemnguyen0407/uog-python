---
title: "Object-oriented Programming"
subtitle: "Special Methods in Python's OOP"
author: |
    Khiem Nguyen 
    <br>Lecturer in Multiscale Materials
    <br><khiem.nguyen@glasgow.ac.uk>
author-meta: "Lecturer in Multiscale Materials"
format: 
    revealjs:
        theme: serif   # other themes: beige, blood, dark, dracula, league, moon, night, serif, simple, sky, solarized
        slide-number: true
        title-slide-style: pandoc
        echo: true
        code-overflow: wrap
        code-line-numbers: true
        code-block-bg: false          # <-- remove white background in code blocks
        # code-block-border-left: false # optional: remove left border
        # highlight-style: monokai      # good for dark images
        toc: true
        toc-depth: 1
        toc-title: Presentation Outline
        css: simple.css
---


# Special methods/Dunder methods
- Learn what Python's **special methods** (**dunder methods** or **magic methods**) are.
- Understand the magic behind magic methods in Python
- Customize different behaviors of your custom classes with **special methods**

## Special methods: Introduction
- A special method is a method whose name starts and ends with a double underscore.
- You already learned one of them: `__init__(self, ...)` is a constructor.
- These sepcial methods are known as **magic methods** or **dunder methods**
- The *double underscores** flag these methods as core to some Python features.

Some popular and well-known special methods:

| Magic Method | Description |
|---|---|
|`__init__()` | Provides an initializer in Python classes |
|`__str__()` | Provide human-read representation for objects |
|`__repr__()` | Provide developer point-of-view representation |
|`__call__()` | Makes instances of a class callable |
|`__len__()` | Supports the `len()` function |

## Special methods: Introduction
Here's how the Python official documentation defines the term **special methods**

> A method that is called implicitly by Python to execute a certain operation on a type, such as addition. Such methods have names starting and ending with double underscores. [Source](https://docs.python.org/3/glossary.html#term-special-method)

## Initializing Objects with `__init__()`

- You have learned it all the way. This method works as an **initializer**/**constructor** because it allows us to provide initial values to any *instance attributes* that we define in our classes.

```{python}
class Complex:
    def __init__(self, real=0, imag=0):
        self.real = real
        self.imag = imag

    def display(self):
        print(f"{self.real} + i*{self.imag}")
```

```{python}
a = Complex()
b = Complex(1, 2)
a.display()     # we wish to write print(a) instead
b.display()     #    wish to write print(b) instead
print(a)
print(b)
```

<!-- ::: {.fragment}
```{python}
# We wish that we can plus two Complex numbers
try:  # This will give error, so I must put in try-except statement
    print(a + b)
except TypeError:
    print("unsupported operand type(s) for +: 'Complex' and 'Complex'") 
```
::: -->

## Representing objects as Strings

- The `.__str__()` special method returns a human-readable string representation of the object. 
    - Python calls this method when we call the built-in `str()` function, passing an instance of the class as an argument.
    - Python also calls this method when we use the instance as an argument to `print()` and `format()` functions.
- The `__repr__()` special method returns a string representation of an object that's targeted at the developer.
    - Ideally, the returned string should be crafted in such a way that you can construct an identical instance of the object from the string.
    - Python calls this method when we call the built-in `repr()` function, passing an instance of the class as an argument.
    - In interactive mode or Jupyter Notebook, this method will be called when we querry the object **WIHTOUT** using function `print()`.

> At this point, I illustrate the difference between `__str__()` and `__repr__()` using NumPy object.

## Representing objects as strings: NumPy example

::: {.fragment}
- Look at this NumPy example
```{python}
import numpy as np
a = np.array([1, 2, 3, 4, 5])
b = np.array([1.1, 2.1, 3.1, 4.1, 5.1])

print(a + b)    # this print out a string

str(a + b) # returns a string that is printed out by the function print
```
:::

::: {.fragment}
- But, if I write `a + b` in the interactive mode, you see the `array()` wrapping around the list of numbers
```{python}
a + b
```

- In fact, the above output is the string given by
```{python}
repr(a + b) # returns a string
```
:::

## User-friendly string representations with `__str__()`
- Let us revisit out `Complex` class
```{python}
class Complex:
    def __init__(self, real=0, imag=0):
        self.real = real
        self.imag = imag

    def __str__(self):
        output = f"{self.real}"
        if self.imag != 0:
            output += f" + {self.imag}*i"
 
        return output
```

- Now, we can print a `Complex` number using `print()`
```{python}
a = Complex()
b = Complex(1, 0)
c = Complex(4, 2)
print(a)
print(b)
print(c)
```

## Developer-friendly string representation with `__repr__()`
- Let us revisit our `Complex` class
```{python}
class Complex:
    def __init__(self, real=0, imag=0):
        self.real = real
        self.imag = imag

    def __repr__(self):
        output = "Complex: " + f"{self.real}"
        if self.imag != 0:
            output += f" + {self.imag}"
        
        return output
```

- Now, we can understand the output represent an object of `Complex` class
```{python}
a = Complex(1, 2)
a
```
- We can examine it closely by using `repr()` function:
```{python}
b = Complex(2, 4)
repr(b)
```

## Overriding operators
- At this point, we want to do some operations on the Complex Number
$$a = 1 + 2 \mathrm{i},\quad b= 2 + \mathrm{i}\quad \Rightarrow\quad a + b = 3 + 3 \mathrm{i}$$
- But, we cannot do this by naively writing the code as follows
```{python}
a = Complex(1, 2)
b = Complex(2, 1)
try: # This will produce an error, I must put it in try-except block
    print(a + b)
except TypeError:
    print("unsupported operand type(s) for +: 'Complex' and 'Complex'")
```

- Computer does not understand concept of Complex number. We must teach it how to do basic operations the way we want, such as 
    - addition (using `__add__()`)
    - subtraction (using `__sub__()`)
    - multiplication (using `__mult__()`)
    - division (using `__div__()`)
    - etc.

## Overriding addition and subtraction
```{python}
class Complex:
    def __init__(self, real=0, imag=0):
        self.real = real; self.imag = imag
    
    def __add__(self, a):
        output = Complex(self.real + a.real, self.imag + b.imag)
        return output

    def __sub__(self, a):
        output = Complex(self.real - a.real, self.imag - b.imag)
        return output
    
    def __str__(self):  # I shorten the code by lazy code
        return f"{self.real} + {self.imag}*i"
    def __repr__(self): # I shorten the code by lazy code
        return f"Complex Number: {self.real} + {self.imag}*i"
```

- Then, we can do addition and subtraction now:
```{python}
a = Complex(1, 2)
b = Complex(2, 1)
print(f"a + b = {a + b}")
print(f"a - b = {a - b}")
a + b, a - b
```